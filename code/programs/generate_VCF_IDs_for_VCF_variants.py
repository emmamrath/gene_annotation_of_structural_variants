#!/usr/bin/python
# python generate_VCF_IDs_for_VCF_variants.py -p prefix_for_VCF_IDs
# cat MGRBp1_mobile_elements_missingsomeXY_QUALgt12_merged100bp_first1000lines.vcf | python generate_VCF_IDs_for_VCF_variants.py -p MEI_ > MGRBp1_MEIs_first1000lines_withprefix.vcf
# cat test1_split.vcf | python generate_VCF_IDs_for_VCF_variants.py -p SV_ > test1_split_with_ID.vcf

# This program takes 1 VCF file on input from stdin, generates a new VCF.ID for each variants, and writes out the VCF file to stdout.
# The VCF.ID will be preceded by the prefix if the prefix input parameter is present.
# For variants already having a VCF.ID, it will be kept and a new one will not be assigned to that variant.

# This program has been created for the structural variant annotation pipeline because that pipeline requires a VCF.ID key.
# Generating VCF.IDs for variants that don't have that allows them to be annotated in the pipeline.
# This program replaces whatever VCF.IDs may be there.
# This is handy for replacing enormously long VCF.IDs that are output by GATK CombineVariants when merging thousands of samples.

__author__ = 'Emma M. Rath'
__copyright__ = 'Copyright 2017, Garvan Institute of Medical Research and Kinghorn Cancer Centre'

import sys
import os
import commands
import argparse

######################################################
def is_integer(s):
	try:
		int(s)
		return True
	except ValueError:
		return False

######################################################
def main():

	# What input arguments have been supplied to the program

	parser = argparse.ArgumentParser(description='Read in an uncompressed VCF file from stdin, assign a new VCF.ID, then output VCF file to stdout.')
	parser.add_argument('-p', action="store", dest="prefix_for_VCF_IDs", required=False, help='If present, this prefix will be prepended to each new VCF.ID generated by this program.')
	args = parser.parse_args()

	# Read in the input VCF file from STDIN and process each record

	in_header = True
	have_outputted_new_info_headers = False
	prev_VCF_ID = ''
	prev_VCF_ID_count = 0

	new_prefix = ''
	if args.prefix_for_VCF_IDs is not None:
		new_prefix = str(args.prefix_for_VCF_IDs)

	for inline in sys.stdin:

		if (in_header == True):
			if (len(inline) >= 1):
				first_char = inline[0:1]
				if (first_char != '#'):
					in_header = False

		if (in_header == True):

			sys.stdout.write( inline ) # Output header lines as-is

		if (in_header == False): # We are processing VCF data records. We are no longer in the header part of the file.

			infields = inline.split("\t")
			VCF_CHROM = infields[0]
			VCF_POS = int(infields[1])
			VCF_ID = infields[2]

			vcf_pos_str = str(VCF_POS)
			if (VCF_POS < 0):
				vcf_pos_str = 'N' + str(abs(VCF_POS))
			new_VCF_ID = new_prefix + str(VCF_CHROM) + "_" + vcf_pos_str
			if (new_VCF_ID == prev_VCF_ID):
				prev_VCF_ID_count = prev_VCF_ID_count + 1
				new_VCF_ID = new_VCF_ID + '_' + str(prev_VCF_ID_count)
			else:
				prev_VCF_ID = new_VCF_ID
				prev_VCF_ID_count = 0

			outline = infields[0]
			for i in range( 1, len(infields) ):
				next_field = infields[i]
				if (i == 2):
					next_field = new_VCF_ID
				outline = outline + "\t" + next_field

			sys.stdout.write( outline )


if __name__=='__main__':
    main()


